import { dequal } from 'dequal';
import { pipe, subscribe } from "wonka";
import { readyLookup, getClient, hydrateQuery } from "@internal/client";
class {
  onCreate(input) {
    let { data, error, opKey, name } = input;
    const state = { data, error, fetching: false };

    if (typeof document !== "undefined") {
      if (opKey) {
        hydrateQuery(opKey, data, error, name);
      } else if (error && error._) {
        state.error = new Error(error.message);
        state.error.name = error.name;
      }

      const ready = readyLookup[this.id];
      if (ready) {
        // Hydration takes a double render pass, we avoid doing a new query until that's done.
        let skipQueries = 2;
        const onRender = () => {
          this.shouldQuery = false;
          if (!--skipQueries) {
            this.removeListener("render", onRender);
            this.doQuery({ requestPolicy: "cache-first" });
          }
        };
        this.on("render", onRender);
        ready();
      } else {
        this.once("mount", () => {
          this.shouldQuery = false;
          this.doQuery();
        });
      }
    }

    this.state = state;
  }

  onInput(input) {
    let { name, query, variables, requestPolicy } = input;

    if (
      this.name !== name ||
      this.query !== query ||
      this.requestPolicy !== requestPolicy ||
      !dequal(this.variables, variables)
    ) {
      this.name = name;
      this.query = query;
      this.variables = variables;
      this.requestPolicy = requestPolicy;
      this.shouldQuery = true;
    }
  }

  onUpdate() {
    if (this.shouldQuery) {
      this.shouldQuery = false;
      this.doQuery();
    }
  }

  onDestroy() {
    this.stopQuery();
    this.stopTimeout();
  }
  stopQuery() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = undefined;
    }
  }
  stopTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = undefined;
    }
  }
  doQuery(options) {
    this.stopTimeout();
    this.stopQuery();
    this.state.fetching = true;

    let timeout = this.input.timeout;
    if (timeout == null) {
      timeout = 10000;
    }

    if (timeout > 0) {
      this.timeoutId = setTimeout(() => {
        this.stopQuery();
        const err = new Error("Timed out after " + timeout + "ms");
        err.code = "ERR_AWAIT_TIMEDOUT";
        err.name = "TimeoutError";
        this.state.data = undefined;
        this.state.error = err;
        this.state.fetching = false;
      }, timeout);
    }

    this.unsubscribe = pipe(
      getClient(undefined, this.input.name).query(
        this.input.query,
        this.input.variables,
        {
          requestPolicy: this.input.requestPolicy,
          ...options,
        },
      ),
      subscribe(({ data, error, stale }) => {
        this.stopTimeout();
        this.state.data = data;
        this.state.error = error;
        this.state.fetching = !!stale;
      }),
    ).unsubscribe;
  }
}

<if(state.data || state.error)>
  <${input.then}(
    state,
    (options) => {
      component.doQuery({ requestPolicy: "network-only", ...options });
    },
  )/>
</if>
<else>
  <${input.placeholder}/>
</else>
