import { pipe, subscribe } from "wonka";
import { readyLookup, getClient, hydrateQuery } from "@internal/client";
static function deepEqual(a, b) {
  return a === b || JSON.stringify(a) === JSON.stringify(b);
}

class {
  onCreate(input) {
    let { data, error } = input;

    if (typeof document !== "undefined") {
      if (error) {
        this.setInput(input);

        if (error._) {
          const { name, message } = error;
          error = new Error(message);
          error.name = name;
        }
      } else if (input.opKey) {
        this.setInput(input);
        const hydrate = (ready) => {
          hydrateQuery(input.opKey, data, error, input.name);
          ready();
        }

        if (readyLookup[this.id]) {
          hydrate(readyLookup[this.id]);
        } else {
          Object.defineProperty(readyLookup, this.id, {
            configurable: true,
            set: hydrate
          });
        }
      }
    }

    this.state = { data, error, fetching: false };
  }

  onUpdate() {
    this.doQuery();
  }

  onMount() {
    this.doQuery();
  }

  onDestroy() {
    this.stopQuery();
    this.stopTimeout();
  }
  stopQuery() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = undefined;
    }
  }
  stopTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = undefined;
    }
  }
  setInput(input) {
    this.name = input.name;
    this.query = input.query;
    this.requestPolicy = input.requestPolicy;
    this.variables = input.variables;
  }
  doQuery(options, force) {
    if (
      this.input.opKey || (
        !force &&
        this.name === this.input.name &&
        this.requestPolicy === this.input.requestPolicy &&
        deepEqual(this.query, this.input.query) &&
        deepEqual(this.variables, this.input.variables)
      )
    ) {
      return;
    }

    this.setInput(this.input);
    this.stopTimeout();
    this.stopQuery();
    this.state.fetching = true;

    let timeout = this.input.timeout;
    if (timeout == null) {
      timeout = 10000;
    }

    if (timeout > 0) {
      this.timeoutId = setTimeout(() => {
        this.stopQuery();
        const err = new Error("Timed out after " + timeout + "ms");
        err.code = "ERR_AWAIT_TIMEDOUT";
        err.name = "TimeoutError";
        this.state.data = undefined;
        this.state.error = err;
        this.state.fetching = false;
      }, timeout);
    }

    this.unsubscribe = pipe(
      getClient(undefined, this.input.name).query(
        this.input.query,
        this.input.variables,
        {
          requestPolicy: this.input.requestPolicy,
          ...options,
        },
      ),
      subscribe(({ data, error, stale }) => {
        this.stopTimeout();
        this.state.data = data;
        this.state.error = error;
        this.state.fetching = !!stale;
      }),
    ).unsubscribe;
  }
}

<if(state.data || state.error)>
  <${input.then}(
    state,
    (options) => {
      component.doQuery({ requestPolicy: "network-only", ...options }, true);
    },
  )/>
</if>
<else>
  <${input.placeholder}/>
</else>
